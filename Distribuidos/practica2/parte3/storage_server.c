/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "storage.h"
#include "operations.h"

bool_t
registeruser_1_svc(char *user, int *result, struct svc_req *rqstp)
{
	bool_t retval;
	*result = registerU(user);

	retval = TRUE;
	return retval;
}

bool_t
unregisteruser_1_svc(char *user, int *result, struct svc_req *rqstp)
{
	bool_t retval;

	*result = unregisterU(user);

	retval = TRUE;

	return retval;
}

bool_t
connectuser_1_svc(char *user, char *ip, int port, int *result, struct svc_req *rqstp)
{
	bool_t retval;

	*result = connectU(user, ip, port);

	retval = TRUE;

	return retval;
}

bool_t
disconnectuser_1_svc(char *user, int *result, struct svc_req *rqstp)
{
	bool_t retval;

	*result = disconnectU(user);

	retval = TRUE;

	return retval;
}

bool_t
publishfile_1_svc(char *user, char *file, char *description, int *result, struct svc_req *rqstp)
{
	bool_t retval;

	*result = publishF(user, file, description);

	retval = TRUE;

	return retval;
}

bool_t
deletefile_1_svc(char *user, char *file, int *result, struct svc_req *rqstp)
{
	bool_t retval;

	*result = deleteF(user, file);

	retval = TRUE;

	return retval;
}

bool_t
listuser_1_svc(char *user, mchains *result, struct svc_req *rqstp)
{
	//result devuelve una matriz de strings siendo el primer elemento el codigo de error 
	//el siguiente el numero de usuarios en caso de cod=0, y a partir de ahi la lista de usuarios
	// direcciones ip y puertos
	bool_t retval;
	char **lista;
	char buffer[MAX_LINE];
	int codigo = list_users(user, &lista);
	if (codigo < 0) // si codigo de error
	{
		// preparo una matriz de strings tamaño 1 para devolverla con el codigo de error
		result->mchains_val = (chain *)malloc(1 * sizeof(chain));
		result->mchains_val[0] = (chain)malloc(MAX_LINE);
		sprintf(buffer, "%d", -codigo);
		strcpy(result->mchains_val[0], buffer); // codigo de error
		result->mchains_len = 1;
	}
	else
	{
		// voy a añadir dos elementos nuevos a lista para meter cod=0(ok) y num de users
		// preparo una matriz de strings tamaño (3*num_users) + 2 para devolverla
		result->mchains_val = (chain *)malloc((codigo + 2) * sizeof(chain));
		result->mchains_val[0] = (chain)malloc(MAX_LINE);
		result->mchains_val[1] = (chain)malloc(MAX_LINE);
		// relleno la primera string con el codigo de ok
		strcpy(result->mchains_val[0], "0"); // codigo ok
		// relleno la segunda string con el codigo de ok
		sprintf(buffer, "%d", codigo);
		strcpy(result->mchains_val[1], buffer); // num elementos
		// relleno las siguientes con la lista de usuarios
		for (int i = 0; i < codigo; i++)
		{
			result->mchains_val[i + 2] = (chain)malloc(MAX_LINE);
			strcpy(result->mchains_val[i + 2], lista[i]); // lista original
		}
		result->mchains_len = codigo + 2;
		// libero la memoria de lista asignada en list_users()
		if (codigo != 0) {
			for (int i = 0; i < codigo; i++) free(lista[i]);
			free(lista);
		}
	}
	
	retval = TRUE;
	return retval;
}

bool_t listcontent_1_svc(char *user, char *puser, mchains *result, struct svc_req *rqstp)
{
	//result devuelve una matriz de strings siendo el primer elemento el codigo de error
	//el siguiente el numero de ficheros en caso de cod=0, y a partir de ahi la lista de files
	//y descripts
	bool_t retval;
	char** lista;
	char buffer[MAX_LINE];
	
	
	int codigo = list_content(user, puser, &lista);
	if (codigo < 0)
	{
		// preparo una matriz de strings tamaño 1 para devolverla con el codigo de error
		result->mchains_val = (chain *)malloc(1 * sizeof(chain));
		result->mchains_val[0] = (chain)malloc(MAX_LINE);
		sprintf(buffer, "%d", -codigo);
		strcpy(result->mchains_val[0], buffer); // codigo de error
		result->mchains_len = 1;
	}
	else
	{
		// voy a añadir dos elementos nuevos a lista para meter cod=0(ok) y num de files
		// preparo una matriz de strings tamaño (3*num_users) + 2 para devolverla
		result->mchains_val = (chain *)malloc((codigo + 2) * sizeof(chain));
		result->mchains_val[0] = (chain)malloc(MAX_LINE);
		result->mchains_val[1] = (chain)malloc(MAX_LINE);
		// relleno la primera string con el codigo de ok
		strcpy(result->mchains_val[0], "0"); // codigo ok
		// relleno la segunda string con el codigo de ok
		sprintf(buffer, "%d", codigo);
		strcpy(result->mchains_val[1], buffer); // num elementos
		// relleno las siguientes con la lista de files
		for (int i = 0; i < codigo; i++)
		{
			result->mchains_val[i + 2] = (chain)malloc(MAX_LINE);
			strcpy(result->mchains_val[i + 2], lista[i]); // lista original
		}
		result->mchains_len = codigo + 2;
		// libero la memoria de lista asignada en list_content()
		if (codigo != 0) {
			for (int i = 0; i < codigo; i++) free(lista[i]);
			free(lista);
		}
	}
	retval = TRUE;
	return retval;
}

int fildistributor_1_freeresult(SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
{
	xdr_free(xdr_result, result);

	return 1;
}



	
